0x0: push 0x0
0x2: push 0xa 0x3a 0x64 0x72 0x6f 0x77 0x73 0x73 0x61 0x70 0x20 0x65 0x68 0x74 0x20 0x72 0x65 0x74 0x6e 0x65 0x20 0x65 0x73 0x61 0x65 0x6c 0x50
0x1f: putc
0x20: push top
0x21: cond jmp 0x1fL
0x23: switch stack
0x24: push -0x1L 	; push into stack 2
0x26: switch stack

0x27: getc 			; getc into stack1
0x28: switch stack
0x29: push 0x1
0x2b: add 			; top++
0x2c: switch stack
0x2d: push top
0x2e: push 0x1
0x30: add
0x31: cond jmp 0x27 ; while(input + 1 != 0)

;push input into stack1
;stack2 record number of valid inputs

0x33: push 0x1
0x35: add 			; 0xff -> 0x00
0x36: switch stack
0x37: pop reg1 		; reg1 = length
0x38: switch stack
0x39: pop reg2		; reg2 = 0, stack1
0x3a: push reg1		; push length into stack1
0x3b: pop n, reverse stack ; reverse input
0x3c: push reg1
0x3d: push -0x19L
0x3f: add
0x40: cond jmp 0x44 ; if length != 0x19, fail
0x42: jmp 0x45
0x44: undefined0xff
0x45: nop
0x46: nop
0x47: jmp 0xcc		; jmp to 0xcc

; 2 arg
0x49: mul 			; (x1*x2)
0x4a: push 0x101
0x4c: mod 			; (x1*x2)%0x101
0x4d: push reg1
0x4e: add 			; (x1*x2) % 0x101 + r1
0x4f: push 0x101
0x51: mod 			; ((x1*x2) % 0x101 + r1) % 0x101
0x52: pop reg1 		; r1 = ((x1*x2) + r1) % 0x101
0x53: ret
;callee pop arg

;consume 5 arg
;callee restore
0x54: push 0x0
0x56: pop reg1 		; reg1 = 0

0x57: push 0x22 	; x2 = 0x22
0x59: call 0x49 	; r1 = ((x1*0x22) + r1) % 0x101

0x5b: push 0x2e 	; r1 = ((x2*0x2e) + r1) % 0x101
0x5d: call 0x49

0x5f: push 0x92
0x61: call 0x49

0x63: push 0x6e
0x65: call 0x49

0x67: push 0xc9
0x69: call 0x49

0x6b: ret

0x6c: push 0x0
0x6e: pop reg1

0x6f: push 0x56
0x71: call 0x49

0x73: push 0x57
0x75: call 0x49

0x77: push 0x9
0x79: call 0x49

0x7b: push 0xff
0x7d: call 0x49

0x7f: push 0x7c
0x81: call 0x49
0x83: ret

0x84: push 0x0
0x86: pop reg1
0x87: push 0x5a
0x89: call 0x49
0x8b: push 0xe2
0x8d: call 0x49
0x8f: push 0x34
0x91: call 0x49
0x93: push 0xf7
0x95: call 0x49
0x97: push 0xde
0x99: call 0x49
0x9b: ret

0x9c: push 0x0
0x9e: pop reg1
0x9f: push 0x39
0xa1: call 0x49
0xa3: push 0x67
0xa5: call 0x49
0xa7: push 0x99
0xa9: call 0x49
0xab: push 0xd2
0xad: call 0x49
0xaf: push 0xaf
0xb1: call 0x49
0xb3: ret

0xb4: push 0x0
0xb6: pop reg1
0xb7: push 0xbe
0xb9: call 0x49
0xbb: push 0xd4
0xbd: call 0x49
0xbf: push 0x2d
0xc1: call 0x49
0xc3: push 0x45
0xc5: call 0x49
0xc7: push 0x7a
0xc9: call 0x49
0xcb: ret

;examine input here
;now stack1 is input being reversed(no null termination)
;stack2 is 0

0xcc: push 0x5
0xce: pop reg2 ; reg2 = 5

0xcf: push 0x5
0xd1: pop n, copy stack ; copy last 5 inputs_rev
0xd2: push 0x5
0xd4: pop n, copy stack ; copy again
0xd5: push 0xa
0xd7: pop n, copy stack ; copy 10, which is copy 4th

0xd8: call 0x54
0xda: switch stack
0xdb: push reg1
0xdc: switch stack

0xdd: call 0x6c
0xdf: switch stack
0xe0: push reg1
0xe1: switch stack

0xe2: call 0x84
0xe4: switch stack
0xe5: push reg1
0xe6: switch stack

0xe7: call 0x9c
0xe9: switch stack
0xea: push reg1
0xeb: switch stack

0xec: call 0xb4
0xee: switch stack
0xef: push reg1
0xf0: switch stack
; 5 bytes, 5th examine, push result into stack2

0xf1: push reg2
0xf2: push -0x1L
0xf4: add
0xf5: push top
0xf6: pop reg2 		;reg2--
0xf7: cond jmp 0xcf ;while(reg2 != 0)


0xf9: switch stack 	; stack2
0xfa: push 0x19
0xfc: pop n, reverse stack ; reverse the order

;second encoding, also reversed in stack

0xfd: push 0x5
0xff: pop reg2 ; reg2 = 5

0x100: push 0x5
0x102: pop n, copy stack
0x103: push 0x5
0x105: pop n, copy stack
0x106: push 0xa
0x108: pop n, copy stack

0x109: call 0x54
0x10b: switch stack
0x10c: push reg1
0x10d: switch stack
0x10e: call 0x6c
0x110: switch stack
0x111: push reg1
0x112: switch stack
0x113: call 0x84
0x115: switch stack
0x116: push reg1
0x117: switch stack
0x118: call 0x9c
0x11a: switch stack
0x11b: push reg1
0x11c: switch stack
0x11d: call 0xb4
0x11f: switch stack
0x120: push reg1
0x121: switch stack

0x122: push reg2
0x123: push -0x1L
0x125: add
0x126: push top
0x127: pop reg2
0x128: cond jmp 0x100 ; while(reg2 != 0)

0x12a: switch stack ;stack1
0x12b: push 0x19
0x12d: pop n, reverse stack
0x12e: switch stack ;stack2

0x12f: push 0xcc 0x8d 0x38 0x1c 0xb0 0x68 0x15 0x7a 0x4c 0x9b 0x95 0xc9 0xea 0xdb 0x31 0x18 0x67 0xba 0x40 0xe 0xa3 0xfd 0xbb 0x5a 0xf3

0x14a: push 0x19
0x14c: pop reg2 ; reg2 = 25

0x14d: pop reg1 ; reg1 = key[i]
0x14e: switch stack ; stack1
0x14f: push reg1
0x150: xor
0x151: cond jmp 0x176 ;not 0, wrong
0x153: switch stack ;stack2

0x154: push reg2
0x155: push -0x1L
0x157: add
0x158: push top
0x159: pop reg2 ; reg2--
0x15a: cond jmp 0x14d ;while(reg2 != 0)

0x15c: push 0x0
0x15e: push 0xa 0x21 0x67 0x61 0x6c 0x66 0x20 0x65 0x68 0x74 0x20 0x73 0x27 0x74 0x61 0x68 0x54 ;goal
0x171: putc
0x172: push top
0x173: cond jmp 0x171L
0x175: exit
0x176: push 0x0
0x178: push 0xa 0x21 0x67 0x6e 0x6f 0x72 0x57
0x181: putc
0x182: push top
0x183: cond jmp 0x181L
0x185: undefined0xff